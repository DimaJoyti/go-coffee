package aiorder

import (
	"context"
	"log"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	pb "github.com/DimaJoyti/go-coffee/api/proto/ai_order"
)

// SimpleService implements a basic AI Order Service without external dependencies
type SimpleService struct {
	pb.UnimplementedAIOrderServiceServer
}

// NewSimpleService creates a new simple AI Order Service instance
func NewSimpleService() *SimpleService {
	return &SimpleService{}
}

// RegisterAIOrderServiceServer registers the service with gRPC server
func RegisterAIOrderServiceServer(s interface{}, srv *SimpleService) {
	// This is a placeholder - in real implementation, this would be generated by protoc
	log.Println("‚úÖ AI Order Service registered")
}

// CreateOrder creates a new order with AI analysis (simplified implementation)
func (s *SimpleService) CreateOrder(ctx context.Context, req *pb.CreateOrderRequest) (*pb.CreateOrderResponse, error) {
	log.Printf("üìù Creating order for customer: %s", req.Customer.Name)

	// Simple validation
	if req.Customer == nil {
		return nil, status.Errorf(codes.InvalidArgument, "customer is required")
	}

	if len(req.Items) == 0 {
		return nil, status.Errorf(codes.InvalidArgument, "at least one item is required")
	}

	// Create a simple order response
	order := &pb.Order{
		Id:       "order-" + generateSimpleID(),
		Customer: req.Customer,
		Items:    req.Items,
		Status:   pb.OrderStatus_ORDER_STATUS_PENDING,
		Priority: pb.OrderPriority_ORDER_PRIORITY_NORMAL,
	}

	// Calculate total amount
	totalAmount := 0.0
	for _, item := range req.Items {
		totalAmount += item.TotalPrice
	}
	order.TotalAmount = totalAmount

	// Simple AI recommendations
	recommendations := []string{
		"Consider adding a pastry to your order",
		"Upgrade to a larger size for better value",
	}

	log.Printf("‚úÖ Order created successfully: %s (Total: $%.2f)", order.Id, order.TotalAmount)

	return &pb.CreateOrderResponse{
		Order:                    order,
		AiRecommendations:        recommendations,
		EstimatedWaitTimeMinutes: 5.0,
		Success:                  true,
		Message:                  "Order created successfully",
	}, nil
}

// GetOrder retrieves an order by ID
func (s *SimpleService) GetOrder(ctx context.Context, req *pb.GetOrderRequest) (*pb.GetOrderResponse, error) {
	log.Printf("üîç Getting order: %s", req.OrderId)

	if req.OrderId == "" {
		return nil, status.Errorf(codes.InvalidArgument, "order_id is required")
	}

	// Create a mock order for demonstration
	order := &pb.Order{
		Id: req.OrderId,
		Customer: &pb.Customer{
			Id:    "customer-123",
			Name:  "John Doe",
			Email: "john@example.com",
		},
		Items: []*pb.OrderItem{
			{
				Id:          "item-1",
				ProductId:   "latte-001",
				ProductName: "Latte",
				Quantity:    1,
				UnitPrice:   4.50,
				TotalPrice:  4.50,
			},
		},
		Status:      pb.OrderStatus_ORDER_STATUS_CONFIRMED,
		Priority:    pb.OrderPriority_ORDER_PRIORITY_NORMAL,
		TotalAmount: 4.50,
	}

	return &pb.GetOrderResponse{
		Order:   order,
		Success: true,
		Message: "Order retrieved successfully",
	}, nil
}

// ListOrders lists orders with optional filtering
func (s *SimpleService) ListOrders(ctx context.Context, req *pb.ListOrdersRequest) (*pb.ListOrdersResponse, error) {
	log.Printf("üìã Listing orders for customer: %s", req.CustomerId)

	// Create mock orders for demonstration
	orders := []*pb.Order{
		{
			Id: "order-001",
			Customer: &pb.Customer{
				Id:    "customer-123",
				Name:  "John Doe",
				Email: "john@example.com",
			},
			Items: []*pb.OrderItem{
				{
					Id:          "item-1",
					ProductId:   "latte-001",
					ProductName: "Latte",
					Quantity:    1,
					UnitPrice:   4.50,
					TotalPrice:  4.50,
				},
			},
			Status:      pb.OrderStatus_ORDER_STATUS_COMPLETED,
			Priority:    pb.OrderPriority_ORDER_PRIORITY_NORMAL,
			TotalAmount: 4.50,
		},
		{
			Id: "order-002",
			Customer: &pb.Customer{
				Id:    "customer-123",
				Name:  "John Doe",
				Email: "john@example.com",
			},
			Items: []*pb.OrderItem{
				{
					Id:          "item-2",
					ProductId:   "americano-001",
					ProductName: "Americano",
					Quantity:    1,
					UnitPrice:   3.75,
					TotalPrice:  3.75,
				},
			},
			Status:      pb.OrderStatus_ORDER_STATUS_PENDING,
			Priority:    pb.OrderPriority_ORDER_PRIORITY_NORMAL,
			TotalAmount: 3.75,
		},
	}

	return &pb.ListOrdersResponse{
		Orders:      orders,
		TotalCount:  int32(len(orders)),
		Success:     true,
		Message:     "Orders retrieved successfully",
	}, nil
}

// UpdateOrderStatus updates the status of an order
func (s *SimpleService) UpdateOrderStatus(ctx context.Context, req *pb.UpdateOrderStatusRequest) (*pb.UpdateOrderStatusResponse, error) {
	log.Printf("üîÑ Updating order %s status to %s", req.OrderId, req.NewStatus.String())

	if req.OrderId == "" {
		return nil, status.Errorf(codes.InvalidArgument, "order_id is required")
	}

	// Create a mock updated order
	order := &pb.Order{
		Id: req.OrderId,
		Customer: &pb.Customer{
			Id:    "customer-123",
			Name:  "John Doe",
			Email: "john@example.com",
		},
		Status:      req.NewStatus,
		Priority:    pb.OrderPriority_ORDER_PRIORITY_NORMAL,
		TotalAmount: 4.50,
	}

	notifications := []string{
		"Order status updated successfully",
		"Customer has been notified",
	}

	return &pb.UpdateOrderStatusResponse{
		Order:           order,
		AiNotifications: notifications,
		Success:         true,
		Message:         "Order status updated successfully",
	}, nil
}

// CancelOrder cancels an order
func (s *SimpleService) CancelOrder(ctx context.Context, req *pb.CancelOrderRequest) (*pb.CancelOrderResponse, error) {
	log.Printf("‚ùå Cancelling order: %s", req.OrderId)

	if req.OrderId == "" {
		return nil, status.Errorf(codes.InvalidArgument, "order_id is required")
	}

	// Create a mock cancelled order
	order := &pb.Order{
		Id: req.OrderId,
		Customer: &pb.Customer{
			Id:    "customer-123",
			Name:  "John Doe",
			Email: "john@example.com",
		},
		Status:      pb.OrderStatus_ORDER_STATUS_CANCELLED,
		Priority:    pb.OrderPriority_ORDER_PRIORITY_NORMAL,
		TotalAmount: 4.50,
	}

	impactAnalysis := &pb.AIImpactAnalysis{
		RevenueImpact:               4.50,
		CustomerSatisfactionImpact:  -0.5,
		MitigationSuggestions:       []string{"Offer 10% discount on next order"},
		KitchenEfficiencyImpact:     0.1,
	}

	return &pb.CancelOrderResponse{
		Order:          order,
		ImpactAnalysis: impactAnalysis,
		Success:        true,
		Message:        "Order cancelled successfully",
	}, nil
}

// GetOrderRecommendations gets AI recommendations for orders
func (s *SimpleService) GetOrderRecommendations(ctx context.Context, req *pb.GetOrderRecommendationsRequest) (*pb.GetOrderRecommendationsResponse, error) {
	log.Printf("ü§ñ Getting recommendations for customer: %s", req.CustomerId)

	recommendations := []*pb.RecommendedItem{
		{
			ProductId:         "latte-001",
			ProductName:       "Latte",
			ConfidenceScore:   0.9,
			Reason:           "Popular choice for morning orders",
			Price:            4.50,
			EstimatedPrepTime: 3.0,
		},
		{
			ProductId:         "croissant-001",
			ProductName:       "Croissant",
			ConfidenceScore:   0.8,
			Reason:           "Perfect pairing with coffee",
			Price:            3.25,
			EstimatedPrepTime: 1.0,
		},
	}

	return &pb.GetOrderRecommendationsResponse{
		Recommendations: recommendations,
		Reasoning:       "Based on your order history and popular items",
		Success:         true,
		Message:         "Recommendations generated successfully",
	}, nil
}

// AnalyzeOrderPatterns analyzes order patterns
func (s *SimpleService) AnalyzeOrderPatterns(ctx context.Context, req *pb.AnalyzeOrderPatternsRequest) (*pb.AnalyzeOrderPatternsResponse, error) {
	log.Printf("üìä Analyzing order patterns for location: %s", req.LocationId)

	insights := []*pb.PatternInsight{
		{
			PatternType:   "temporal",
			Description:   "Peak ordering hours: 8-10 AM and 2-4 PM",
			Confidence:    0.92,
			AffectedItems: []string{"latte", "americano"},
			TimePeriod:    "daily",
			ImpactScore:   8.5,
		},
	}

	recommendations := []string{
		"Increase staff during peak hours",
		"Prepare popular items in advance",
	}

	return &pb.AnalyzeOrderPatternsResponse{
		Insights:        insights,
		Recommendations: recommendations,
		Success:         true,
		Message:         "Pattern analysis completed",
	}, nil
}

// PredictCompletionTime predicts order completion time
func (s *SimpleService) PredictCompletionTime(ctx context.Context, req *pb.PredictCompletionTimeRequest) (*pb.PredictCompletionTimeResponse, error) {
	log.Printf("‚è±Ô∏è Predicting completion time for order: %s", req.OrderId)

	return &pb.PredictCompletionTimeResponse{
		EstimatedMinutes:    5.0,
		ConfidenceLevel:     0.85,
		Factors:            []string{"Current queue size", "Order complexity"},
		Success:            true,
		Message:            "Completion time predicted successfully",
	}, nil
}

// Helper function to generate simple IDs
func generateSimpleID() string {
	// Simple ID generation for demo purposes
	return "123456"
}
