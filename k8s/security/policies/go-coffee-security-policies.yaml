# Go Coffee Platform Security Policies
# Comprehensive security policies for OPA Gatekeeper

---
# Policy: Require Security Context
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeesecuritycontext
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeSecurityContext
      validation:
        openAPIV3Schema:
          type: object
          properties:
            runAsNonRoot:
              type: boolean
            runAsUser:
              type: integer
              minimum: 1000
            fsGroup:
              type: integer
              minimum: 1000
            allowPrivilegeEscalation:
              type: boolean
            readOnlyRootFilesystem:
              type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeesecuritycontext

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsNonRoot
          msg := "Container must run as non-root user"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.runAsUser < 1000
          msg := "Container must run as user ID >= 1000"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.allowPrivilegeEscalation == true
          msg := "Container must not allow privilege escalation"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.readOnlyRootFilesystem
          msg := "Container must have read-only root filesystem"
        }

---
# Constraint: Apply Security Context Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeSecurityContext
metadata:
  name: go-coffee-security-context
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    excludedNamespaces: ["kube-system", "gatekeeper-system", "security", "monitoring"]
  parameters:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true

---
# Policy: Require Resource Limits
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeeresourcelimits
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeResourceLimits
      validation:
        openAPIV3Schema:
          type: object
          properties:
            maxCpu:
              type: string
            maxMemory:
              type: string
            minCpu:
              type: string
            minMemory:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeeresourcelimits

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.resources.limits.cpu
          msg := "Container must have CPU limits"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.resources.limits.memory
          msg := "Container must have memory limits"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.resources.requests.cpu
          msg := "Container must have CPU requests"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.resources.requests.memory
          msg := "Container must have memory requests"
        }

---
# Constraint: Apply Resource Limits Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeResourceLimits
metadata:
  name: go-coffee-resource-limits
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    excludedNamespaces: ["kube-system", "gatekeeper-system", "security", "monitoring"]
  parameters:
    maxCpu: "2000m"
    maxMemory: "4Gi"
    minCpu: "100m"
    minMemory: "128Mi"

---
# Policy: Disallow Privileged Containers
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeenoprivileged
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeNoPrivileged
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeenoprivileged

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.privileged
          msg := "Privileged containers are not allowed"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.initContainers[_]
          container.securityContext.privileged
          msg := "Privileged init containers are not allowed"
        }

---
# Constraint: Apply No Privileged Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeNoPrivileged
metadata:
  name: go-coffee-no-privileged
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
      - apiGroups: [""]
        kinds: ["Pod"]
    excludedNamespaces: ["kube-system", "gatekeeper-system", "security"]

---
# Policy: Require Image Pull Policy
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeeimagepullpolicy
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeImagePullPolicy
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowedPullPolicies:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeeimagepullpolicy

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.imagePullPolicy in input.parameters.allowedPullPolicies
          msg := sprintf("Container image pull policy must be one of: %v", [input.parameters.allowedPullPolicies])
        }

---
# Constraint: Apply Image Pull Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeImagePullPolicy
metadata:
  name: go-coffee-image-pull-policy
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    excludedNamespaces: ["kube-system", "gatekeeper-system"]
  parameters:
    allowedPullPolicies: ["Always", "IfNotPresent"]

---
# Policy: Require Trusted Image Registries
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeetrustedregistries
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeTrustedRegistries
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowedRegistries:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeetrustedregistries

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          image := container.image
          not starts_with_allowed_registry(image)
          msg := sprintf("Container image '%v' is not from a trusted registry. Allowed registries: %v", [image, input.parameters.allowedRegistries])
        }

        starts_with_allowed_registry(image) {
          registry := input.parameters.allowedRegistries[_]
          startswith(image, registry)
        }

---
# Constraint: Apply Trusted Registries Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeTrustedRegistries
metadata:
  name: go-coffee-trusted-registries
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    excludedNamespaces: ["kube-system", "gatekeeper-system", "security", "monitoring"]
  parameters:
    allowedRegistries:
      - "gcr.io/go-coffee/"
      - "docker.io/go-coffee/"
      - "public.ecr.aws/go-coffee/"
      - "ghcr.io/go-coffee/"

---
# Policy: Require Network Policies
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeenetworkpolicy
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeNetworkPolicy
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeenetworkpolicy

        violation[{"msg": msg}] {
          input.review.kind.kind == "Namespace"
          input.review.operation == "CREATE"
          namespace := input.review.object.metadata.name
          not has_network_policy(namespace)
          msg := sprintf("Namespace '%v' must have a NetworkPolicy", [namespace])
        }

        has_network_policy(namespace) {
          # This would need to be implemented with external data
          # For now, we'll assume all namespaces should have network policies
          false
        }

---
# Policy: Require Labels
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeerequiredlabels
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeRequiredLabels
      validation:
        openAPIV3Schema:
          type: object
          properties:
            requiredLabels:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeerequiredlabels

        violation[{"msg": msg}] {
          required_label := input.parameters.requiredLabels[_]
          not input.review.object.metadata.labels[required_label]
          msg := sprintf("Missing required label: %v", [required_label])
        }

---
# Constraint: Apply Required Labels Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeRequiredLabels
metadata:
  name: go-coffee-required-labels
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
      - apiGroups: [""]
        kinds: ["Service", "ConfigMap", "Secret"]
    excludedNamespaces: ["kube-system", "gatekeeper-system"]
  parameters:
    requiredLabels:
      - "app.kubernetes.io/name"
      - "app.kubernetes.io/component"
      - "environment"

---
# Policy: Disallow Host Network
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeenohostnetwork
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeNoHostNetwork
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeenohostnetwork

        violation[{"msg": msg}] {
          input.review.object.spec.hostNetwork
          msg := "Host network is not allowed"
        }

---
# Constraint: Apply No Host Network Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeNoHostNetwork
metadata:
  name: go-coffee-no-host-network
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet", "DaemonSet"]
      - apiGroups: [""]
        kinds: ["Pod"]
    excludedNamespaces: ["kube-system", "gatekeeper-system", "security"]

---
# Policy: Require Probes
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: gocoffeerequireprobes
  labels:
    app.kubernetes.io/name: go-coffee
    app.kubernetes.io/component: security-policy
spec:
  crd:
    spec:
      names:
        kind: GoCoffeeRequireProbes
      validation:
        openAPIV3Schema:
          type: object
          properties:
            requireLivenessProbe:
              type: boolean
            requireReadinessProbe:
              type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package gocoffeerequireprobes

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          input.parameters.requireLivenessProbe
          not container.livenessProbe
          msg := "Container must have a liveness probe"
        }

        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          input.parameters.requireReadinessProbe
          not container.readinessProbe
          msg := "Container must have a readiness probe"
        }

---
# Constraint: Apply Require Probes Policy
apiVersion: config.gatekeeper.sh/v1alpha1
kind: GoCoffeeRequireProbes
metadata:
  name: go-coffee-require-probes
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment", "StatefulSet"]
    excludedNamespaces: ["kube-system", "gatekeeper-system", "security", "monitoring"]
  parameters:
    requireLivenessProbe: true
    requireReadinessProbe: true
