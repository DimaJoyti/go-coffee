package telegram

import (
	"context"
	"fmt"
	"math/big"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

	"github.com/DimaJoyti/go-coffee/web3-wallet-backend/internal/ai"
	"github.com/DimaJoyti/go-coffee/web3-wallet-backend/pkg/models"
)

// PaymentRequest represents a payment request
type PaymentRequest struct {
	UserID        int64     `json:"user_id"`
	OrderID       string    `json:"order_id"`
	Amount        float64   `json:"amount_usd"`
	Currency      string    `json:"currency"`
	WalletAddress string    `json:"wallet_address"`
	CreatedAt     time.Time `json:"created_at"`
	ExpiresAt     time.Time `json:"expires_at"`
	Status        string    `json:"status"`
}

// CryptoPaymentInfo represents crypto payment information
type CryptoPaymentInfo struct {
	Currency      string  `json:"currency"`
	Amount        string  `json:"amount"`
	Address       string  `json:"address"`
	QRCode        string  `json:"qr_code,omitempty"`
	ExchangeRate  float64 `json:"exchange_rate"`
	NetworkFee    string  `json:"network_fee"`
	TotalRequired string  `json:"total_required"`
}

// processPaymentRequest processes a crypto payment request
func (b *Bot) processPaymentRequest(ctx context.Context, session *UserSession, currency string, amount float64) error {
	b.logger.Info(fmt.Sprintf("Processing payment request for user %d: %.2f USD in %s", session.UserID, amount, currency))

	// Generate payment address and details
	paymentInfo, err := b.generatePaymentInfo(ctx, currency, amount)
	if err != nil {
		return fmt.Errorf("failed to generate payment info: %w", err)
	}

	// Create payment request
	paymentReq := &PaymentRequest{
		UserID:        session.UserID,
		OrderID:       fmt.Sprintf("order_%d_%d", session.UserID, time.Now().Unix()),
		Amount:        amount,
		Currency:      currency,
		WalletAddress: paymentInfo.Address,
		CreatedAt:     time.Now(),
		ExpiresAt:     time.Now().Add(30 * time.Minute), // 30 minutes to pay
		Status:        "pending",
	}

	// Store payment request in session
	session.Context["payment_request"] = paymentReq
	session.Context["payment_info"] = paymentInfo

	// Send payment instructions
	return b.sendPaymentInstructions(session.ChatID, paymentInfo, paymentReq)
}

// generatePaymentInfo generates payment information for the specified currency
func (b *Bot) generatePaymentInfo(ctx context.Context, currency string, amountUSD float64) (*CryptoPaymentInfo, error) {
	// Get current exchange rates (mock implementation)
	exchangeRates := map[string]float64{
		"btc":  42000.0,  // 1 BTC = $42,000
		"eth":  2800.0,   // 1 ETH = $2,800
		"usdc": 1.0,      // 1 USDC = $1
		"usdt": 1.0,      // 1 USDT = $1
		"sol":  95.0,     // 1 SOL = $95
	}

	rate, exists := exchangeRates[strings.ToLower(currency)]
	if !exists {
		return nil, fmt.Errorf("unsupported currency: %s", currency)
	}

	// Calculate crypto amount
	cryptoAmount := amountUSD / rate

	// Generate wallet address (mock implementation)
	address := b.generateWalletAddress(currency)

	// Calculate network fees (mock implementation)
	networkFees := map[string]string{
		"btc":  "0.0001",
		"eth":  "0.002",
		"usdc": "0.002", // Same as ETH since it's ERC-20
		"usdt": "0.002", // Same as ETH since it's ERC-20
		"sol":  "0.00025",
	}

	fee := networkFees[strings.ToLower(currency)]
	
	return &CryptoPaymentInfo{
		Currency:      strings.ToUpper(currency),
		Amount:        fmt.Sprintf("%.8f", cryptoAmount),
		Address:       address,
		ExchangeRate:  rate,
		NetworkFee:    fee,
		TotalRequired: fmt.Sprintf("%.8f", cryptoAmount),
	}, nil
}

// generateWalletAddress generates a wallet address for the specified currency
func (b *Bot) generateWalletAddress(currency string) string {
	// Mock wallet addresses - in production, these would be generated by the wallet service
	addresses := map[string]string{
		"btc":  "bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh",
		"eth":  "0x742d35Cc6634C0532925a3b8D4C0d886E5d4f2a0",
		"usdc": "0x742d35Cc6634C0532925a3b8D4C0d886E5d4f2a0",
		"usdt": "0x742d35Cc6634C0532925a3b8D4C0d886E5d4f2a0",
		"sol":  "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
	}

	if addr, exists := addresses[strings.ToLower(currency)]; exists {
		return addr
	}

	// Fallback to a generic address
	return "0x742d35Cc6634C0532925a3b8D4C0d886E5d4f2a0"
}

// sendPaymentInstructions sends payment instructions to the user
func (b *Bot) sendPaymentInstructions(chatID int64, paymentInfo *CryptoPaymentInfo, paymentReq *PaymentRequest) error {
	instructionsText := fmt.Sprintf(`üí≥ *–û–ø–ª–∞—Ç–∞ %s*

*–î–µ—Ç–∞–ª—ñ –ø–ª–∞—Ç–µ–∂—É:*
‚Ä¢ –°—É–º–∞: %s %s
‚Ä¢ –ö—É—Ä—Å: $%.2f –∑–∞ 1 %s
‚Ä¢ –ö–æ–º—ñ—Å—ñ—è –º–µ—Ä–µ–∂—ñ: %s %s

*–ê–¥—Ä–µ—Å–∞ –¥–ª—è –ø–µ—Ä–µ–∫–∞–∑—É:*
`+"`%s`"+`

‚ö†Ô∏è *–í–∞–∂–ª–∏–≤–æ:*
‚Ä¢ –í—ñ–¥–ø—Ä–∞–≤—Ç–µ —Ç–æ—á–Ω–æ %s %s
‚Ä¢ –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ç—ñ–ª—å–∫–∏ –≤–∫–∞–∑–∞–Ω—É –∞–¥—Ä–µ—Å—É
‚Ä¢ –ü–ª–∞—Ç—ñ–∂ –¥—ñ–π—Å–Ω–∏–π –ø—Ä–æ—Ç—è–≥–æ–º 30 —Ö–≤–∏–ª–∏–Ω
‚Ä¢ –ü—ñ—Å–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å "–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –ø–ª–∞—Ç—ñ–∂"

*–°—Ç–∞—Ç—É—Å:* –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –ø–ª–∞—Ç–µ–∂—É...`,
		paymentInfo.Currency,
		paymentInfo.Amount, paymentInfo.Currency,
		paymentInfo.ExchangeRate, paymentInfo.Currency,
		paymentInfo.NetworkFee, paymentInfo.Currency,
		paymentInfo.Address,
		paymentInfo.TotalRequired, paymentInfo.Currency,
	)

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –ø–ª–∞—Ç—ñ–∂", "confirm_payment"),
			tgbotapi.NewInlineKeyboardButtonData("üìã –ö–æ–ø—ñ—é–≤–∞—Ç–∏ –∞–¥—Ä–µ—Å—É", "copy_address"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîÑ –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å—Ç–∞—Ç—É—Å", "check_payment_status"),
			tgbotapi.NewInlineKeyboardButtonData("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", "cancel_payment"),
		),
	)

	return b.sendMessageWithKeyboard(chatID, instructionsText, keyboard)
}

// handlePaymentConfirmation handles payment confirmation
func (b *Bot) handlePaymentConfirmation(ctx context.Context, callback *tgbotapi.CallbackQuery, session *UserSession) {
	paymentReq, exists := session.Context["payment_request"].(*PaymentRequest)
	if !exists {
		b.sendMessage(session.ChatID, "‚ùå –ü–ª–∞—Ç—ñ–∂–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞. –ü–æ—á–Ω—ñ—Ç—å –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è.")
		return
	}

	// Check if payment has expired
	if time.Now().After(paymentReq.ExpiresAt) {
		b.sendMessage(session.ChatID, "‚è∞ –ß–∞—Å –¥–ª—è –æ–ø–ª–∞—Ç–∏ –≤–∏—á–µ—Ä–ø–∞–Ω–æ. –ü–æ—á–Ω—ñ—Ç—å –Ω–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è.")
		session.State = StateIdle
		delete(session.Context, "payment_request")
		delete(session.Context, "payment_info")
		return
	}

	// Simulate payment verification (in production, this would check blockchain)
	verified := b.verifyPayment(ctx, paymentReq)

	if verified {
		b.handleSuccessfulPayment(ctx, session, paymentReq)
	} else {
		b.handlePendingPayment(ctx, session, paymentReq)
	}
}

// verifyPayment verifies if payment has been received
func (b *Bot) verifyPayment(ctx context.Context, paymentReq *PaymentRequest) bool {
	// Mock verification - in production, this would check blockchain transactions
	// For demo purposes, randomly return true 30% of the time
	return time.Now().Unix()%10 < 3
}

// handleSuccessfulPayment handles successful payment
func (b *Bot) handleSuccessfulPayment(ctx context.Context, session *UserSession, paymentReq *PaymentRequest) {
	successText := fmt.Sprintf(`üéâ *–ü–ª–∞—Ç—ñ–∂ —É—Å–ø—ñ—à–Ω–æ –æ—Ç—Ä–∏–º–∞–Ω–æ!*

*–î–µ—Ç–∞–ª—ñ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó:*
‚Ä¢ ID –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è: %s
‚Ä¢ –°—É–º–∞: %.2f USD
‚Ä¢ –í–∞–ª—é—Ç–∞: %s
‚Ä¢ –°—Ç–∞—Ç—É—Å: ‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ

–í–∞—à–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è –ø–µ—Ä–µ–¥–∞–Ω–æ –≤ —Ä–æ–±–æ—Ç—É —ñ –±—É–¥–µ –≥–æ—Ç–æ–≤–µ —á–µ—Ä–µ–∑ 5-10 —Ö–≤–∏–ª–∏–Ω.

–î—è–∫—É—î–º–æ –∑–∞ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è! ‚òïÔ∏è`,
		paymentReq.OrderID,
		paymentReq.Amount,
		paymentReq.Currency,
	)

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üì¶ –ú–æ—ó –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è", "my_orders"),
			tgbotapi.NewInlineKeyboardButtonData("‚òïÔ∏è –ù–æ–≤–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è", "start_order"),
		),
	)

	b.sendMessageWithKeyboard(session.ChatID, successText, keyboard)

	// Clean up session
	session.State = StateIdle
	delete(session.Context, "payment_request")
	delete(session.Context, "payment_info")
	delete(session.Context, "pending_order")
}

// handlePendingPayment handles pending payment
func (b *Bot) handlePendingPayment(ctx context.Context, session *UserSession, paymentReq *PaymentRequest) {
	pendingText := fmt.Sprintf(`‚è≥ *–ü–ª–∞—Ç—ñ–∂ —â–µ –Ω–µ –æ—Ç—Ä–∏–º–∞–Ω–æ*

–ú–∏ –Ω–µ –∑–Ω–∞–π—à–ª–∏ –≤–∞—à –ø–ª–∞—Ç—ñ–∂ –Ω–∞ –±–ª–æ–∫—á–µ–π–Ω—ñ. –¶–µ –º–æ–∂–µ –∑–∞–π–Ω—è—Ç–∏ –∫—ñ–ª—å–∫–∞ —Ö–≤–∏–ª–∏–Ω.

*–©–æ —Ä–æ–±–∏—Ç–∏:*
‚Ä¢ –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ –≤—ñ–¥–ø—Ä–∞–≤–∏–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—É —Å—É–º—É
‚Ä¢ –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∞–¥—Ä–µ—Å—É –æ—Ç—Ä–∏–º—É–≤–∞—á–∞
‚Ä¢ –ó–∞—á–µ–∫–∞–π—Ç–µ –∫—ñ–ª—å–∫–∞ —Ö–≤–∏–ª–∏–Ω –¥–ª—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è

*–ß–∞—Å –¥–æ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è:* %s`,
		paymentReq.ExpiresAt.Sub(time.Now()).Round(time.Minute),
	)

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîÑ –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∑–Ω–æ–≤—É", "confirm_payment"),
			tgbotapi.NewInlineKeyboardButtonData("üìã –ü–æ–∫–∞–∑–∞—Ç–∏ –∞–¥—Ä–µ—Å—É", "show_payment_address"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏ –ø–ª–∞—Ç—ñ–∂", "cancel_payment"),
		),
	)

	b.sendMessageWithKeyboard(session.ChatID, pendingText, keyboard)
}

// handlePaymentStatusCheck handles payment status check
func (b *Bot) handlePaymentStatusCheck(ctx context.Context, callback *tgbotapi.CallbackQuery, session *UserSession) {
	paymentReq, exists := session.Context["payment_request"].(*PaymentRequest)
	if !exists {
		answerCallback := tgbotapi.NewCallbackWithAlert(callback.ID, "‚ùå –ü–ª–∞—Ç—ñ–∂–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞")
		b.api.Request(answerCallback)
		return
	}

	// Check payment status
	verified := b.verifyPayment(ctx, paymentReq)
	
	if verified {
		answerCallback := tgbotapi.NewCallbackWithAlert(callback.ID, "‚úÖ –ü–ª–∞—Ç—ñ–∂ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ!")
		b.api.Request(answerCallback)
		b.handleSuccessfulPayment(ctx, session, paymentReq)
	} else {
		answerCallback := tgbotapi.NewCallbackWithAlert(callback.ID, "‚è≥ –ü–ª–∞—Ç—ñ–∂ —â–µ –æ–±—Ä–æ–±–ª—è—î—Ç—å—Å—è...")
		b.api.Request(answerCallback)
	}
}
